"""This file defines a class `DigitalPyService` that inherits from `Service`, `ZmqSubscriber`, and `ZMQPusher`. This class is used to create a service that can subscribe to messages, push messages, and perform service-related operations.

The class constructor takes several parameters including service id, addresses, ports, protocols, a formatter, and a network interface. It initializes the parent classes and sets up various properties.

The class has several properties with their respective getters and setters, such as `protocol`, `status`, and `tracer`.

The class also defines several methods, some of which are abstract and must be implemented by any class that inherits from `DigitalPyService`. These include `event_loop`, `handle_command`, and `handle_exception`.

The `start` method is used to start the service. It configures the object factory, initializes the tracer, initializes the controllers, and starts the event loop. If a network is provided, it also initializes the network.

The `__getstate__` and `__setstate__` methods are used for pickling and unpickling the object, respectively.
"""
#######################################################
#
# DigitalPyService.py
# Python implementation of the Class DigitalPyService
# Generated by Enterprise Architect
# Created on:      02-Dec-2022 5:39:44 PM
# Original author: Giu Platania
#
#######################################################
from datetime import datetime
from typing import List
import time
from digitalpy.core.domain.domain.service_health import ServiceHealth
from digitalpy.core.main.impl.default_factory import DefaultFactory
from digitalpy.core.main.object_factory import ObjectFactory
from digitalpy.core.service_management.domain.service_status import ServiceStatus
from digitalpy.core.telemetry.tracing_provider import TracingProvider
from digitalpy.core.telemetry.tracer import Tracer
from digitalpy.core.zmanager.service import Service
from digitalpy.core.zmanager.impl.zmq_subscriber import ZmqSubscriber
from digitalpy.core.zmanager.impl.zmq_pusher import ZMQPusher
from digitalpy.core.parsing.formatter import Formatter
from digitalpy.core.network.network_interface import NetworkInterface
from digitalpy.core.zmanager.response import Response
from digitalpy.core.IAM.IAM_facade import IAM
from digitalpy.core.domain.domain.network_client import NetworkClient
from digitalpy.core.zmanager.request import Request
from digitalpy.core.health.domain.service_health_category import ServiceHealthCategory
from digitalpy.core.digipy_configuration.configuration import Configuration

COMMAND_PROTOCOL = "command"
COMMAND_ACTION = "ServiceCommand"


class DigitalPyService(Service, ZmqSubscriber, ZMQPusher):
    # on the reception of messages from the subscriber interface or the socket

    def __init__(self, service_id: str,
                 subject_address: str,
                 subject_port: int,
                 subject_protocol: str,
                 integration_manager_address: str,
                 integration_manager_port: int,
                 integration_manager_protocol: str,
                 formatter: Formatter,
                 network: NetworkInterface,
                 protocol: str,
                 error_threshold: float = 0.1):
        """the constructor for the digitalpy service class

        Args:
            service_id (str): the unique id of the service inheriting from DigitalpyService
            subject_address (str): the address of the zmanager "subject"
            subject_port (int): the port of the zmanager "subject"
            subject_protocol (str): the protocol of the zmanager "subject"
            integration_manager_address (str): the address of the zmanager "integration_manager"
            integration_manager_port (int): the port of the zmanager "integration_manager"
            integration_manager_protocol (str): the protocol of the zmanager "integration_manager"
            formatter (Formatter): the formatter used by the service to serialize the request values to and from messages, (should be injected by object factory)
            network (NetworkInterface): the network interface used by the service to send and receive messages, (should be injected by object factory through the services' constructor)
            protocol (str): the protocol of the service
        """
        Service.__init__(self)
        ZmqSubscriber.__init__(self, formatter)
        ZMQPusher.__init__(self, formatter)
        self.subject_address = subject_address
        self.subject_port = subject_port
        self.subject_protocol = subject_protocol
        self.integration_manager_address = integration_manager_address
        self.integration_manager_port = integration_manager_port
        self.integration_manager_protocol = integration_manager_protocol
        self.service_id = service_id
        self._tracer = None
        self.status = ServiceStatus.UNKNOWN
        self.network = network
        self.protocol = protocol
        self.response_queue: List[Response] = []
        self.iam_facade: IAM = ObjectFactory.get_instance("IAM")

        self.total_requests = 0
        self.total_errors = 0
        self.total_request_processing_time = 0
        self.error_threshold = error_threshold

    def handle_connection(self, client: NetworkClient, req: Request):
        """register a client with the server. This method should be called when a client connects to the server
        so that it can be registered with the IAM component.
        Args:
            client (NetworkClient): the client to register
        """

        resp = ObjectFactory.get_new_instance("Response")
        client.service_id = self.service_id
        client.protocol = self.protocol
        self.iam_facade.initialize(req, resp)
        req.set_value("connection", client)
        self.iam_facade.execute("connection")
        return

    def handle_disconnection(self, client: NetworkClient, req: Request):
        """unregister a client from the server. This method should be called when a client disconnects from the server
        so that it can be unregistered from the IAM component.
        Args:
            client (NetworkClient): the client to unregister
        """
        resp = ObjectFactory.get_new_instance("Response")
        req.set_value("connection_id", str(client.get_oid()))
        self.iam_facade.initialize(req, resp)
        self.iam_facade.execute("disconnection")
        return

    @property
    def protocol(self):
        return self._protocol

    @protocol.setter
    def protocol(self, protocol: str):
        self._protocol = protocol

    @property
    def status(self):
        return self._status

    @status.setter
    def status(self, status: ServiceStatus):
        self._status = status

    @property
    def tracer(self):
        if self._tracer is None:
            raise ValueError("Tracer has not been initialized")
        else:
            return self._tracer

    @tracer.setter
    def tracer(self, value):
        if self._tracer is not None:
            raise ValueError("Tracer has already been initialized")
        elif not isinstance(value, Tracer):
            raise ValueError("Tracer must be an instance of TracingProvider")
        self._tracer = value

    def discovery(self):
        """used to  inform the discoverer of the specifics of this service"""
        # TODO: the contract for discovery needs to be established
        # example for potential implementation
        return "service desc"

    def send_heart_beat(self):
        """used to inform the service menager that this service is still alive"""
        # TODO: once the service manager has been well defined then we will need
        # to define the format for this service.

    def initialize_controllers(self):
        """used to initialize the controllers once the service is started. Should be overriden by inheriting classes"""

    def initialize_connections(self, application_protocol: str):
        """initialize connections to the subject and the integration manager

        Args:
            application_protocol (str): the application protocol of the service
        """
        ZMQPusher.initiate_connections(
            self, self.subject_port, self.subject_address, self.service_id)
        self.broker_connect(self.integration_manager_address, self.integration_manager_port,
                            self.integration_manager_protocol, self.service_id, application_protocol)

    def response_handler(self, responses: List[Response]):
        """used to handle a response. Should be overriden by inheriting classes"""
        for response in responses:
            if response.get_action() == COMMAND_ACTION:
                self.handle_command(response)
            else:
                self.handle_response(response)

    def handle_response(self, response: Response):
        """used to handle a response. Should be overriden by inheriting classes"""
        if self.network:
            if response.get_value("recipients") == "*":
                self.network.send_message_to_all_clients(response)
            else:
                self.network.send_message_to_clients(
                    response, response.get_value("recipients"))

    def event_loop(self):
        """used to run the service. Should be overriden by inheriting classes"""
        responses = self.broker_receive()
        self.response_handler(responses)

    def stop(self):
        self.status = ServiceStatus.STOPPING

        if self.network:
            self.network.teardown_network()

        self.broker_disconnect()
        self.teardown_connections()

        self.status = ServiceStatus.STOPPED

        raise SystemExit

    def handle_command(self, command: Response):
        """used to handle a command. Should be overriden by inheriting classes"""
        if command.get_value("command") == "stop_service":
            self.stop()
        elif command.get_value("command") == "get_health":
            service_health = self.get_health()
            conf: Configuration = ObjectFactory.get_instance("Configuration")
            resp = ObjectFactory.get_new_instance("Response")
            resp.set_value("message", service_health)
            resp.set_action("publish")
            resp.set_format("pickled")
            resp.set_id(command.get_id())
            self.subject_send_request(resp, COMMAND_PROTOCOL, conf.get_value(
                "service_id", "ServiceManager"))

    def get_health(self):
        """used to get the health of the service."""
        service_health: ServiceHealth = ServiceHealth()
        if self.total_requests == 0:
            service_health.error_percentage = 0
            service_health.average_request_time = 0
        else:
            service_health.error_percentage = self.total_errors/self.total_requests
            service_health.average_request_time = self.total_request_processing_time/self.total_requests
        service_health.service_id = self.service_id
        service_health.status = self.calculate_health(service_health)
        service_health.timestamp = datetime.now()
        return service_health

    def calculate_health(self, service_health: ServiceHealth):
        """used to calculate the health of the service."""
        if service_health.error_percentage > self.error_threshold:
            return ServiceHealthCategory.DEGRADED
        else:
            return ServiceHealthCategory.OPERATIONAL

    def handle_exception(self, exception: Exception):
        """used to handle an exception. Should be overriden by inheriting classes"""
        if isinstance(exception, SystemExit):
            self.status = ServiceStatus.STOPPED
            return
        else:
            self.total_errors += 1

    def start(self, object_factory: DefaultFactory, tracing_provider: TracingProvider, host: str = "", port: int = 0):
        """used to start the service and initialize the network if provided

        Args:
            object_factory (DefaultFactory): the object factory used to create instances of objects
            tracing_provider (TracingProvider): the tracing provider used to create a tracer
            host (str, optional): the host of the network. Defaults to "".
            port (int, optional): the port of the network. Defaults to 0.
        """

        ObjectFactory.configure(object_factory)
        self.tracer = tracing_provider.create_tracer(self.service_id)
        self.initialize_controllers()
        self.initialize_connections(self.protocol)

        if self.network and host and port:
            self.network.intialize_network(host, port)

        elif self.network:
            raise ValueError(
                "network has been injected but host and port have not been provided")
        self.status = ServiceStatus.RUNNING
        self.execute_main_loop()

    def execute_main_loop(self):
        """used to execute the main loop of the service"""
        while self.status == ServiceStatus.RUNNING:
            try:
                self.event_loop()
            except Exception as ex:
                self.handle_exception(ex)
        if self.status == ServiceStatus.STOPPED:
            exit(0)

    def __getstate__(self):
        ZmqSubscriber.__getstate__(self)
        ZMQPusher.__getstate__(self)
        return self.__dict__

    def __setstate__(self, state):
        ZmqSubscriber.__setstate__(self, state)
        ZMQPusher.__setstate__(self, self.__dict__)
