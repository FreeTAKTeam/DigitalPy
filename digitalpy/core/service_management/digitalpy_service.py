"""
This file defines a class `DigitalPyService` that inherits from `Service`, `ZmqSubscriber`, 
and `ZMQPusher`. This class is used to create a service that can subscribe to messages, push messages, 
and perform service-related operations.

The class constructor takes several parameters including service id, addresses, ports, protocols, 
a formatter, and a network interface. It initializes the parent classes and sets up various 
properties.

The class has several properties with their respective getters and setters, such as 
`protocol`, `status`, and `tracer`.

The class also defines several methods, some of which are abstract and must be implemented 
by any class that inherits from `DigitalPyService`. These include `event_loop`, 
`handle_command`, and `handle_exception`.

The `start` method is used to start the service. It configures the object factory, 
initializes the tracer, initializes the controllers, and starts the event loop. 
If a network is provided, it also initializes the network.

The `__getstate__` and `__setstate__` methods are used for pickling and unpickling the object, 
respectively.
"""
#######################################################
#
# DigitalPyService.py
# Python implementation of the Class DigitalPyService
# Generated by Enterprise Architect
# Created on:      02-Dec-2022 5:39:44 PM
# Original author: Giu Platania
#
#######################################################
from datetime import datetime
import traceback
from typing import List

from digitalpy.core.domain.domain.service_health import ServiceHealth
from digitalpy.core.main.impl.default_factory import DefaultFactory
from digitalpy.core.main.object_factory import ObjectFactory
from digitalpy.core.service_management.domain.service_operations import ServiceOperations
from digitalpy.core.service_management.domain.service_status import ServiceStatus
from digitalpy.core.telemetry.tracing_provider import TracingProvider
from digitalpy.core.telemetry.tracer import Tracer
from digitalpy.core.zmanager.service import Service
from digitalpy.core.zmanager.impl.zmq_subscriber import ZmqSubscriber
from digitalpy.core.zmanager.impl.zmq_pusher import ZMQPusher
from digitalpy.core.parsing.formatter import Formatter
from digitalpy.core.network.network_interface import NetworkInterface
from digitalpy.core.zmanager.response import Response
from digitalpy.core.IAM.IAM_facade import IAM
from digitalpy.core.domain.domain.network_client import NetworkClient
from digitalpy.core.zmanager.request import Request
from digitalpy.core.health.domain.service_health_category import ServiceHealthCategory
from digitalpy.core.digipy_configuration.configuration import Configuration

COMMAND_PROTOCOL = "command"
COMMAND_ACTION = "ServiceCommand"


class DigitalPyService(Service, ZmqSubscriber, ZMQPusher):
    """
    Represents a DigitalPy service.

    This class is responsible for managing the lifecycle and behavior of a DigitalPy service.
    It inherits from the Service, ZmqSubscriber, and ZMQPusher classes.

    Args:
        service_id (str): The unique ID of the service inheriting from DigitalPyService.
        subject_address (str): The address of the zmanager "subject".
        subject_port (int): The port of the zmanager "subject".
        subject_protocol (str): The protocol of the zmanager "subject".
        integration_manager_address (str): The address of the zmanager "integration_manager".
        integration_manager_port (int): The port of the zmanager "integration_manager".
        integration_manager_protocol (str): The protocol of the zmanager "integration_manager".
        formatter (Formatter): The formatter used by the service to serialize the request 
            values to and from messages.
        network (NetworkInterface): The network interface used by the service to send and 
            receive messages.
        protocol (str): The protocol of the service.
        error_threshold (float, optional): The error threshold for the service. Defaults to 0.1.
    """

    def __init__(self, service_id: str,
                 subject_address: str,
                 subject_port: int,
                 subject_protocol: str,
                 integration_manager_address: str,
                 integration_manager_port: int,
                 integration_manager_protocol: str,
                 formatter: Formatter,
                 network: NetworkInterface,
                 protocol: str,
                 error_threshold: float = 0.1):
        """the constructor for the digitalpy service class

        Args:
            service_id (str): the unique id of the service inheriting from DigitalpyService
            subject_address (str): the address of the zmanager "subject"
            subject_port (int): the port of the zmanager "subject"
            subject_protocol (str): the protocol of the zmanager "subject"
            integration_manager_address (str): the address of the zmanager "integration_manager"
            integration_manager_port (int): the port of the zmanager "integration_manager"
            integration_manager_protocol (str): the protocol of the zmanager "integration_manager"
            formatter (Formatter): the formatter used by the service to serialize the request values to and from messages, (should be injected by object factory)
            network (NetworkInterface): the network interface used by the service to send and receive messages, (should be injected by object factory through the services' constructor)
            protocol (str): the protocol of the service
        """
        Service.__init__(self)
        ZmqSubscriber.__init__(self, formatter)
        ZMQPusher.__init__(self, formatter)
        self.subject_address = subject_address
        self.subject_port = subject_port
        self.subject_protocol = subject_protocol
        self.integration_manager_address = integration_manager_address
        self.integration_manager_port = integration_manager_port
        self.integration_manager_protocol = integration_manager_protocol
        self.service_id = service_id
        self._tracer = None
        self.status = ServiceStatus.UNKNOWN
        self.network = network
        self.protocol = protocol
        self.response_queue: List[Response] = []
        self.iam_facade: IAM = ObjectFactory.get_instance("IAM")

        self.total_requests = 0
        self.total_errors = 0
        self.total_request_processing_time = 0
        self.error_threshold = error_threshold

    def handle_connection(self, client: NetworkClient, req: Request):
        """register a client with the server. This method should be called when a client connects to the server
        so that it can be registered with the IAM component.
        Args:
            client (NetworkClient): the client to register
            req (Request): the request from the client containing connection data
        """

        resp = ObjectFactory.get_new_instance("Response")
        client.service_id = self.service_id
        client.protocol = self.protocol
        self.iam_facade.initialize(req, resp)
        req.set_value("connection", client)
        self.iam_facade.execute("connection")
        return

    def handle_disconnection(self, client: NetworkClient, req: Request):
        """unregister a client from the server. This method should be called when a client disconnects from the server
        so that it can be unregistered from the IAM component.
        Args:
            client (NetworkClient): the client to unregister
            req (Request): the request from the client containing disconnection data
        """
        resp = ObjectFactory.get_new_instance("Response")
        req.set_value("connection_id", str(client.get_oid()))
        self.iam_facade.initialize(req, resp)
        self.iam_facade.execute("disconnection")
        return

    @property
    def protocol(self) -> str:
        """get the protocol of the service

        Returns:
            str: the protocol of the service
        """
        return self._protocol

    @protocol.setter
    def protocol(self, protocol: str):
        """set the protocol of the service

        Args:
            protocol (str): the protocol of the service
        """
        self._protocol = protocol

    @property
    def status(self) -> ServiceStatus:
        """get the status of the service

        Returns:
            ServiceStatus: the status of the service
        """
        return self._status

    @status.setter
    def status(self, status: ServiceStatus):
        self._status = status

    @property
    def tracer(self) -> Tracer:
        """get the tracer of the service

        Raises:
            ValueError: if the tracer has not been initialized it will raise a value error

        Returns:
            Tracer: the tracer of the service
        """
        if self._tracer is None:
            raise ValueError("Tracer has not been initialized")
        else:
            return self._tracer

    @tracer.setter
    def tracer(self, value: Tracer):
        """set the tracer of the service

        Args:
            value (Tracer): the tracer of the service

        Raises:
            ValueError: if the tracer has already been initialized it will raise a value error
            ValueError: if the value is not an instance of Tracer it will raise a value error
        """
        if self._tracer is not None:
            raise ValueError("Tracer has already been initialized")
        elif not isinstance(value, Tracer):
            raise ValueError("Tracer must be an instance of TracingProvider")
        self._tracer = value

    def discovery(self):
        """used to  inform the discoverer of the specifics of this service"""
        # TODO: the contract for discovery needs to be established
        # example for potential implementation
        return "service desc"

    def send_heart_beat(self):
        """used to inform the service menager that this service is still alive"""
        # TODO: once the service manager has been well defined then we will need
        # to define the format for this service.

    def initialize_controllers(self):
        """used to initialize the controllers once the service is started. Should be overriden 
        by inheriting classes
        """

    def initialize_connections(self, application_protocol: str):
        """initialize connections to the subject and the integration manager within the
        zmanager architecture. The topic subscribed to by the subject is as follows:
        /messages/<service_id>
        /commands/<service_id>

        Args:
            application_protocol (str): the application protocol of the service
        """
        ZMQPusher.initiate_connections(
            self, self.subject_port, self.subject_address, self.service_id)
        self.broker_connect(self.integration_manager_address, self.integration_manager_port,
                            self.integration_manager_protocol, self.service_id,
                            application_protocol)

    def response_handler(self, responses: List[Response]):
        """used to handle a response. Should be overriden by inheriting classes"""
        for response in responses:
            if response.get_action() == COMMAND_ACTION:
                self.handle_command(response)
            else:
                self.handle_response(response)
                
    def handle_response(self, response: Response):
        """used to handle a response. Should be overriden by inheriting classes"""
        if self.network:
            response.set_value("client", response.get_value("recipients"))
            self.network.send_response(response)

    def event_loop(self):
        """used to run the service. Should be overriden by inheriting classes"""
        if self.network:
            self.handle_network()

        responses = self.broker_receive()
        self.response_handler(responses)

    def handle_network(self):
        """used to handle the network."""
        requests = self.network.service_connections()
        for request in requests:
            self.handle_inbound_message(request)

    def stop(self):
        """
        Stops the service by performing necessary cleanup operations.

        This method sets the service status to STOPPING, tears down the network if it exists,
        disconnects the broker, tears down connections, sets the service status to STOPPED,
        and raises SystemExit to exit the program.
        """
        self.status = ServiceStatus.STOPPING

        if self.network:
            self.network.teardown_network()

        self.broker_disconnect()
        self.teardown_connections()

        self.status = ServiceStatus.STOPPED

        raise SystemExit

    def handle_inbound_message(self, message: Request) -> bool:
        """This function is used to handle inbound messages from other services. 
        It is intiated by the event loop.

        Args:
            message (Request): the message to handle

        Returns:
            bool: True if the message was handled successfully, False otherwise
        """

        # TODO: discuss this with giu and see if we should move the to the action mapping system?
        if message.get_value("action") == "connection":
            self.handle_connection(message.get_value("client"), message)
            return True

        elif message.get_value("action") == "disconnection":
            self.handle_disconnection(message.get_value("client"), message)
            return True

        return False

    def handle_command(self, command: Response):
        """used to handle a command. Should be overriden by inheriting classes"""
        if command.get_value("command") == ServiceOperations.STOP.value:
            self.stop()
        elif command.get_value("command") == ServiceOperations.GET_HEALTH.value:
            service_health = self.get_health()
            conf: Configuration = ObjectFactory.get_instance("Configuration")
            resp = ObjectFactory.get_new_instance("Response")
            resp.set_value("message", service_health)
            resp.set_action("publish")
            resp.set_format("pickled")
            resp.set_id(command.get_id())
            self.subject_send_request(resp, COMMAND_PROTOCOL, conf.get_value(
                "service_id", "ServiceManager"))

    def get_health(self):
        """used to get the health of the service."""
        service_health: ServiceHealth = ServiceHealth()
        if self.total_requests == 0:
            service_health.error_percentage = 0
            service_health.average_request_time = 0
        else:
            service_health.error_percentage = self.total_errors/self.total_requests
            service_health.average_request_time = self.total_request_processing_time/self.total_requests
        service_health.service_id = self.service_id
        service_health.status = self.calculate_health(service_health)
        service_health.timestamp = datetime.now()
        return service_health

    def calculate_health(self, service_health: ServiceHealth):
        """used to calculate the health of the service."""
        if service_health.error_percentage > self.error_threshold:
            return ServiceHealthCategory.DEGRADED
        else:
            return ServiceHealthCategory.OPERATIONAL

    def handle_exception(self, exception: Exception):
        """This function is used to handle exceptions that occur in the service. 
        It is intiated by the event loop.
        """
        if isinstance(exception, SystemExit):
            self.status = ServiceStatus.STOPPED
            raise SystemExit
        else:
            traceback.print_exc()
            print("An exception occurred: " + str(exception))
            self.total_errors += 1

    def start(self, object_factory: DefaultFactory, tracing_provider: TracingProvider, host: str = "", port: int = 0):
        """used to start the service and initialize the network if provided

        Args:
            object_factory (DefaultFactory): the object factory used to create instances of objects
            tracing_provider (TracingProvider): the tracing provider used to create a tracer
            host (str, optional): the host of the network. Defaults to "".
            port (int, optional): the port of the network. Defaults to 0.
        """

        ObjectFactory.configure(object_factory)
        self.tracer = tracing_provider.create_tracer(self.service_id)
        self.initialize_controllers()
        self.initialize_connections(self.protocol)

        if self.network and host and port:
            self.network.intialize_network(host, port)

        elif self.network:
            raise ValueError(
                "network has been injected but host and port have not been provided")
        self.status = ServiceStatus.RUNNING
        self.execute_main_loop()

    def execute_main_loop(self):
        """used to execute the main loop of the service"""
        while self.status == ServiceStatus.RUNNING:
            try:
                self.event_loop()
            except Exception as ex:
                self.handle_exception(ex)
        if self.status == ServiceStatus.STOPPED:
            exit(0)

    def __getstate__(self):
        ZmqSubscriber.__getstate__(self)
        ZMQPusher.__getstate__(self)
        return self.__dict__

    def __setstate__(self, state):
        ZmqSubscriber.__setstate__(self, state)
        ZMQPusher.__setstate__(self, self.__dict__)
