#######################################################
#
# core_name_controller.py
# Python implementation of the Class service_management
# Generated by Enterprise Architect
# Created on:      16-Dec-2022 10:56:02 AM
# Original author: Giu Platania
#
#######################################################
from typing import List, Union, TYPE_CHECKING

from digitalpy.core.main.object_factory import ObjectFactory
from digitalpy.core.zmanager.configuration.zmanager_constants import ZMANAGER_MESSAGE_DELIMITER
from digitalpy.core.zmanager.request import Request
from digitalpy.core.zmanager.response import Response
from digitalpy.core.main.controller import Controller

if TYPE_CHECKING:
    from digitalpy.core.IAM.IAM_facade import IAM


USER_DELIMITER = ";"


class ServiceManagementSenderController(Controller):
    """contains the business logic related to sending messages to services
    """

    def __init__(self, request, response, service_management_action_mapper, sync_action_mapper, configuration):
        super().__init__(request, response, sync_action_mapper, configuration)
        self.iam: IAM = ObjectFactory.get_instance("IAM")

    def initialize(self, request: Request, response: Response):
        self.request = request
        self.response = response
        self.iam.initialize(request, response)

    def broadcast_service_management(self, Event):
        """this method will broadcast the component
        """
        pass

    def publish(self, recipients: Union[List[str], str], **kwargs) -> List[str]:
        """this method is used to create the topic to publish a message
        to a set of services based on the recipients

        Args:
            recipients (Union[List[str], str]): a list of recipients id's or a * representing that the message should be sent to all connected clients

        Returns:
            List[str]: a list of topics to which the message should be published

        """
        main_topics: dict = {}

        return_topics: List[str] = []

        # case in which a specific set of users are meant to receive a given message
        if isinstance(recipients, list):
            main_topics.update(self.create_user_specific_topic(recipients))

        # case in which the message should be sent to all recipients
        elif isinstance(recipients, str) and recipients == "*":
            self.create_all_user_topic(main_topics)

        else:
            raise ValueError(
                "The recipients must be a list of recipients id's or a * representing that the message should be sent to all connected clients")

        # iterate the main topics dictionary,
        # concatenate the ids and finally add them
        # all into one list
        # TODO add memoization to prevent duplicate serialization of the same protocol
        for main_topic, ids in main_topics.items():
            self.request.set_value("protocol", main_topic.split("/")[2])
            sub_response = self.execute_sub_action("serialize")
            formatter = ObjectFactory.get_instance("formatter")
            formatter.serialize(sub_response)
            return_topics.append(main_topic.encode() +
                                 ids.encode()+ZMANAGER_MESSAGE_DELIMITER+sub_response.get_values())
        if self.response.get_value("topics") is not None:
            self.response.get_value("topics").extend(return_topics)
        else:
            self.response.set_value("topics", return_topics)

    def create_all_user_topic(self, main_topics):
        self.iam.get_all_connections()

        # filter the recipients based on the request
        self.iam.filter_recipients(
            self.response.get_value("connections"))

        for recipient_object in self.response.get_value("connections"):
            recipient_main_topic = f"/{recipient_object.service_id}/{recipient_object.protocol}/{self.response.get_sender()}/{self.response.get_context()}/{self.response.get_action()}/{self.response.get_id()}/"
            if recipient_main_topic not in main_topics:
                main_topics[recipient_main_topic] = ""

    def create_user_specific_topic(self, recipients: list[str]) -> dict[str, str]:
        """this method is used to create the topic to publish a message

        Args:
            recipients (list[str]): a list of recipients id's

        Returns:
            dict[str, str]: a dictionary containing the main topic as key and the concatenated ids as value
        """
        topics = {}

        # get the connection objects from the IAM
        self.iam.get_connections_by_id(recipients)

        # filter the recipients based on the request
        self.iam.filter_recipients(
            recipients=self.response.get_value("connections"))

        # iterate the recipients and create the main topic
        for recipient_object in self.response.get_value("connections"):

            recipient_main_topic = f"/{recipient_object.service_id}/{recipient_object.protocol}/{self.response.get_sender()}/{self.response.get_context()}/{self.response.get_action()}/{self.response.get_id()}/"
            # if the main topic is already present in the dictionary, concatenate the connection id
            if recipient_main_topic in topics:
                topics[recipient_main_topic] += str(
                    recipient_object.get_oid())+USER_DELIMITER
        # if the main topic is not present in the dictionary, add it with the connection id
            else:
                topics[recipient_main_topic] = str(
                    recipient_object.get_oid())+USER_DELIMITER

        return topics

    def execute(self, method=None):
        pass
